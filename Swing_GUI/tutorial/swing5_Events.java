package tutorial;

import java.awt.Button;
import java.awt.FlowLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JFrame;
/*
 * Procedural vs. Event-Driven Programming
 Handling GUI Events
 Events
 User Actions
 Event Handlers
 Examples
 */

/*
 * Procedural vs. Event-Driven Programming
 Procedural programming is executed in
procedural order.
 In event-driven programming, code is executed
upon activation of events.

Events
 An event can be defined as a type of
signal to the program that something
has happened.
 The event is generated by external
user actions such as mouse
movements, mouse clicks, and
keystrokes, or by the operating
system, such as a timer.
 */

/*Ex of Event-Driven Programming
The example displays a button in the frame. A
message is displayed on the console when a
button is clicked.
*/

public class swing5_Events implements ActionListener {
	Button firstBtn, secondBtn, thirdBtn, fourthBtn;

	public static void main(String[] args) {
		new swing5_Events();
	}// end main fun

	swing5_Events() {
		JFrame f = new JFrame();

		firstBtn = new Button("First");
		f.add(firstBtn);
		secondBtn = new Button("Second");
		f.add(secondBtn);
		thirdBtn = new Button("Third");
		f.add(thirdBtn);
		fourthBtn = new Button("Fourth");
		f.add(fourthBtn);
		// Button fiveBtn = new Button("five");// here wrong we dont need it

		// first in same blocks write dirctly form interface, hard readabilty,not good
		firstBtn.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) {
				System.out.println("first in working");
			}
		});

		// second create object from class implement ActionListener, same third
		MyListenerClass cancelListener = new MyListenerClass();// prefer if you use it with multi components
		secondBtn.addActionListener(cancelListener);

		// third create direct new class implement ActionListener second shorts & best
		// prefer if you use it one time with one component
		thirdBtn.addActionListener(new MyListenerClass());
		// notes if you in static method you can't access feilds inner not static dirctly
		// notes2 ListenerClass that prefer inner class to access private fields

		// forth: create direct in same Class is implement ActionListener
		// & Override method, but here you have one ActionListener,not good exept you
		// need one method or object from ActionListener like calculator
		fourthBtn.addActionListener(this);

		// five create direct new class implement ActionListener
		// you can by design use other class(inner or outer) for access to GUI
		// feilds,work good with
		// button, but you cant later get & set fields by this
		f.add(new FiveBtn(this));// nearly == second == third else constructur take this useful somtimes need
									// fast btn

		//working btn with first run only
		f.add(new sexBtn());// nearly == second == third else constructur take this useful somtimes need
							// fast btn

		// class(inner or outer) like 2,3,5 long write but good & best for maintainable
		// code & organization & big programs

		f.setLayout(new FlowLayout());
		swing3_LayoutManagers.runGui(f);
	}

	// becuese inner make it static to access directly to it
	private class MyListenerClass implements ActionListener {
		@Override
		public void actionPerformed(ActionEvent e) {
			// String s=e.getActionCommand().getTitle();
			if (e.getSource() == secondBtn)
				System.out.println("second in clicked");
			else if (e.getSource() == thirdBtn)
				System.out.println("third in clicked");

		}
	}// end inner class

	@Override
	public void actionPerformed(ActionEvent e) {
		System.out.println("four in clicked");
	}

	public void printFive() {
		System.out.println("five in clicked");
	}

	// static class FiveBtn extends JButton {
	// FiveBtn(p5Events thisOb) {
	// super("FiveBtn in Super");
	// addActionListener(e -> thisOb.printFive());
	// }
	// }// end five class or

}// end Main class

class FiveBtn extends JButton {
	private final swing5_Events thisOb;

	FiveBtn(ActionListener thisOb) {// because impl ActionListener
		super("FiveBtn in Super");
		this.thisOb = (swing5_Events)thisOb;
		addActionListener(e -> this.thisOb.printFive());
	}
}// end five class


//working btn with first run only
class sexBtn extends JButton {
	sexBtn() {
		super("Sex btn");
		System.out.println("sex in clicked");
	}
}// end sex class
